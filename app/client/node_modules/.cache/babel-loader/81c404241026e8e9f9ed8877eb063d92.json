{"ast":null,"code":"import _asyncToGenerator from \"/home/dennis/work/dev/clients/accion/vertigo/app/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _wrapAsyncGenerator from \"/home/dennis/work/dev/clients/accion/vertigo/app/client/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/home/dennis/work/dev/clients/accion/vertigo/app/client/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/home/dennis/work/dev/clients/accion/vertigo/app/client/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/home/dennis/work/dev/clients/accion/vertigo/app/client/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.symbol.async-iterator.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nexport var streamChunk = /*#__PURE__*/regeneratorRuntime.mark(function streamChunk(chunk, chunkSize) {\n  var len, pos, end;\n  return regeneratorRuntime.wrap(function streamChunk$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          len = chunk.byteLength;\n\n          if (!(!chunkSize || len < chunkSize)) {\n            _context.next = 5;\n            break;\n          }\n\n          _context.next = 4;\n          return chunk;\n\n        case 4:\n          return _context.abrupt(\"return\");\n\n        case 5:\n          pos = 0;\n\n        case 6:\n          if (!(pos < len)) {\n            _context.next = 13;\n            break;\n          }\n\n          end = pos + chunkSize;\n          _context.next = 10;\n          return chunk.slice(pos, end);\n\n        case 10:\n          pos = end;\n          _context.next = 6;\n          break;\n\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, streamChunk);\n});\nexport var readBytes = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(iterable, chunkSize) {\n    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n\n    return regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context2.prev = 2;\n            _iterator = _asyncIterator(readStream(iterable));\n\n          case 4:\n            _context2.next = 6;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 6:\n            if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n              _context2.next = 12;\n              break;\n            }\n\n            chunk = _step.value;\n            return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(streamChunk(chunk, chunkSize)), _awaitAsyncGenerator), \"t0\", 9);\n\n          case 9:\n            _iteratorAbruptCompletion = false;\n            _context2.next = 4;\n            break;\n\n          case 12:\n            _context2.next = 18;\n            break;\n\n          case 14:\n            _context2.prev = 14;\n            _context2.t1 = _context2[\"catch\"](2);\n            _didIteratorError = true;\n            _iteratorError = _context2.t1;\n\n          case 18:\n            _context2.prev = 18;\n            _context2.prev = 19;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context2.next = 23;\n              break;\n            }\n\n            _context2.next = 23;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 23:\n            _context2.prev = 23;\n\n            if (!_didIteratorError) {\n              _context2.next = 26;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 26:\n            return _context2.finish(23);\n\n          case 27:\n            return _context2.finish(18);\n\n          case 28:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[2, 14, 18, 28], [19,, 23, 27]]);\n  }));\n\n  return function readBytes(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar readStream = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(stream) {\n    var reader, _yield$_awaitAsyncGen, done, value;\n\n    return regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!stream[Symbol.asyncIterator]) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(stream), _awaitAsyncGenerator), \"t0\", 2);\n\n          case 2:\n            return _context3.abrupt(\"return\");\n\n          case 3:\n            reader = stream.getReader();\n            _context3.prev = 4;\n\n          case 5:\n            _context3.next = 7;\n            return _awaitAsyncGenerator(reader.read());\n\n          case 7:\n            _yield$_awaitAsyncGen = _context3.sent;\n            done = _yield$_awaitAsyncGen.done;\n            value = _yield$_awaitAsyncGen.value;\n\n            if (!done) {\n              _context3.next = 12;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 16);\n\n          case 12:\n            _context3.next = 14;\n            return value;\n\n          case 14:\n            _context3.next = 5;\n            break;\n\n          case 16:\n            _context3.prev = 16;\n            _context3.next = 19;\n            return _awaitAsyncGenerator(reader.cancel());\n\n          case 19:\n            return _context3.finish(16);\n\n          case 20:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2, null, [[4,, 16, 20]]);\n  }));\n\n  return function readStream(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport var trackStream = function trackStream(stream, chunkSize, onProgress, onFinish) {\n  var iterator = readBytes(stream, chunkSize);\n  var bytes = 0;\n  var done;\n\n  var _onFinish = function _onFinish(e) {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  };\n\n  return new ReadableStream({\n    pull: function pull(controller) {\n      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var _yield$iterator$next, _done, value, len, loadedBytes;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return iterator.next();\n\n              case 3:\n                _yield$iterator$next = _context4.sent;\n                _done = _yield$iterator$next.done;\n                value = _yield$iterator$next.value;\n\n                if (!_done) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                _onFinish();\n\n                controller.close();\n                return _context4.abrupt(\"return\");\n\n              case 10:\n                len = value.byteLength;\n\n                if (onProgress) {\n                  loadedBytes = bytes += len;\n                  onProgress(loadedBytes);\n                }\n\n                controller.enqueue(new Uint8Array(value));\n                _context4.next = 19;\n                break;\n\n              case 15:\n                _context4.prev = 15;\n                _context4.t0 = _context4[\"catch\"](0);\n\n                _onFinish(_context4.t0);\n\n                throw _context4.t0;\n\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, null, [[0, 15]]);\n      }))();\n    },\n    cancel: function cancel(reason) {\n      _onFinish(reason);\n\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  });\n};","map":{"version":3,"sources":["/home/dennis/work/dev/clients/accion/vertigo/app/client/node_modules/axios/lib/helpers/trackStream.js"],"names":["streamChunk","chunk","chunkSize","len","byteLength","pos","end","slice","readBytes","iterable","readStream","stream","Symbol","asyncIterator","reader","getReader","read","done","value","cancel","trackStream","onProgress","onFinish","iterator","bytes","_onFinish","e","ReadableStream","pull","controller","next","close","loadedBytes","enqueue","Uint8Array","reason","return","highWaterMark"],"mappings":"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","sourcesContent":["\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nexport const readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nexport const trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n"]},"metadata":{},"sourceType":"module"}